# The folders in third_party are "filtered" copies of other Git repositories -
# only a single revision, with only the files we need plus files that may
# contain legal information (e.g. README and LICENSE files).
#
# Running this script will update these repositories, and stage any changes
# in Git. (Note that you should not need to do this to build the nvpro-samples
# - please create an issue instead.)
#
# Requires Python 3.10 or newer.

import argparse, datetime, glob, os, shutil, stat, subprocess, json


def run(cmd, pipe_output: bool = False) -> bytes:
    print(f"Running {cmd}", flush=True)
    stdout_hook = subprocess.PIPE if pipe_output else None
    return subprocess.run(
        cmd, shell=isinstance(cmd, str), check=True, stdout=stdout_hook
    ).stdout


def on_error_enable_write_access_and_retry(func, path, excinfo):
    # Does the path exist, at least?
    if os.path.exists(path):
        # Try making it writable
        os.chmod(path, stat.S_IWUSR | os.stat(path).st_mode)
        func(path)
    else:
        raise


def rm_recursive_if_exists(path: str):
    print(f"Removing {path}")
    if os.path.exists(path):
        if os.path.isdir(path):
            shutil.rmtree(path, onerror=on_error_enable_write_access_and_retry)
        else:
            os.remove(path)


def rebuild(repository: dict):
    """
    Removes and recreates a single third_party "filtered repository".

    Parameters
    ----------
    repository : dict
        A dictionary containing information about a repository. This function
        can read the following fields:
            "name": The folder name in third_party to place the repository's files.

            "url": https:// or ssh:// URL for the upstream .git repository.

            "branch" (str, optional): If specified, downloads a specific branch
            of the repository. For instance, this can be used to pin a
            dependency to a specific version or feature branch. The default is
            None.

            "remove_globs" (list[str], optional): Each element is a glob
            specification; files matching any specification will be removed.
            The default is [].

        This function adds the following fields to repository_data:
            "last_updated_utc": UTC time when the repository was pulled.

            "last_commit_hash": Commit hash pulled.

            "last_commit_time": ISO 8601 time (with time zone) of the last
            commit made.

    Raises
    ------
    RuntimeError
        If the folder to clone to isn't a third_party directory.

    Returns
    -------
    None.

    """
    script_dir = os.path.dirname(os.path.abspath(__file__))
    clone_folder_absolute = os.path.abspath(
        os.path.join(script_dir, repository["name"])
    )
    # Some quick checks to make sure we don't remove the root directory
    if "third_party" not in clone_folder_absolute:
        raise RuntimeError(
            f"script_dir {script_dir} didn't seem to be the third_party directory."
        )
    try:
        run(["git", "rm", "-r", "-f", clone_folder_absolute])
    except Exception as e:
        print(f"git rm failed with code {e}")
    # Also delete any left-over files that Git doesn't track
    rm_recursive_if_exists(clone_folder_absolute)
    # Clone the repository there.
    # Surprisingly, this works even if nvpro_core itself is a Git repo!
    clone_args = [
        "git",
        "clone",
        "--depth",
        "1",
        "--recurse-submodules",
        "--single-branch",
    ]
    branch = repository["branch"]
    if branch != "None":
        clone_args += ["--branch", branch]
    clone_args += ["--", repository["url"], clone_folder_absolute]
    run(clone_args)
    # Get information about the cloned Git repo
    autogen_info = {}
    autogen_info["last_updated_utc"] = datetime.datetime.now(
        tz=datetime.timezone.utc
    ).isoformat()
    autogen_info["last_commit_hash"] = (
        run(["git", "-C", clone_folder_absolute, "rev-parse", "HEAD"], pipe_output=True)
        .decode("utf-8")
        .strip()
    )
    autogen_info["last_commit_time"] = (
        run(
            [
                "git",
                "-C",
                clone_folder_absolute,
                "log",
                "-1",
                "--date=iso-strict",
                "--format=%ad",
            ],
            pipe_output=True,
        )
        .decode("utf-8")
        .strip()
    )
    repository["info_autogenerated_from_above"] = autogen_info
    # Always remove the git history, plus some standard file names.
    remove_globs = [
        ".git",
        ".gitattributes",
        ".github",
        "**/.gitignore",
        ".travis.yml",
        ".circleci",
        ".clang-format",
        "appveyor.yml",
        "**/*.sln",
        "**/*.vcxproj",
        "**/*.vcxproj.filters",
        "**/*.sh",
        "**/*.com",
        "**/*.bat",
        "**/*.manifest",
        "**/Makefile",
        "**/MAKEFILE",
        "**/*.mk",
        "**/*.pdf",
    ] + repository["rules"]
    # Iterate over filters and remove any found files.
    for globspec in remove_globs:
        paths = glob.glob(globspec, root_dir=clone_folder_absolute, recursive=True)
        for path in paths:
            rm_recursive_if_exists(os.path.join(clone_folder_absolute, path))
    # Sometimes nvpro_core ignores files from subrepos. But adding `-f` is not
    # the best solution, because if we do that, it'll trip up the bulk-update
    # script later.
    # Instead, if you run into this, fix nvpro_core's .gitignore. (You can add
    # ! at the start of lines to make .gitignore not apply to certain directories.)
    run(["git", "add", clone_folder_absolute])


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="dev-rebuild-filtered-repos",
        description='The folders in third_party are "filtered" copies of other Git repositories; this script updates them.',
    )
    parser.add_argument(
        "repositories",
        nargs="+",
        default=[],
        help="Names of repositories from repro_rules.json to update. You can specify multiple repositories like this: `dev-rebuild-filtered-repos.py imgui format stb`. By default, updates every repository.",
    )
    args = parser.parse_args()

    # Load the JSON file with repository rules
    with open("repro_rules.json", "r") as json_file:
        data = json.load(json_file)
    # Rebuild them; note that rebuild() can modify each element:
    for repository in data["repositories"]:
        if len(args.repositories) > 0:
            if repository["name"] not in args.repositories:
                continue
        rebuild(repository)
    # Save updated data
    with open("repro_rules.json", "w") as json_file:
        json_file.write(json.dumps(data, indent=4))
    # And now that we've saved that, add the file to git:
    run(["git", "add", "repro_rules.json"])
